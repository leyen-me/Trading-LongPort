// ================================
// åŸä½œè€…:   Leyen
// æ€è·¯æ•´ç†: Qwen3/235B-A22B-2507
// ä»£ç ç¼–å†™: ChatGPT
// æ ¸å¿ƒç†å¿µ: ç›˜æ•´ç§¯è“„ï¼Œçªç ´é‡Šæ”¾ï¼Œæ”¾é‡ç¡®è®¤
// å“²å­¦ç†å¿µ: å¸‚åœºä»ä¸ç¼ºæœºä¼šï¼Œç¼ºçš„æ˜¯èƒ½åœ¨â€˜æ­»å¯‚ä¸­å¬è§å¿ƒè·³â€™çš„è€³æœµ
// ================================

// ================================
// ğŸ“Š
// æµ‹è¯•æ ‡çš„: TSLL 
// æµ‹è¯•å‘¨æœŸ: 5MIN
// æµ‹è¯•æ¨èå‚æ•°ï¼š12 8 0.25 1.4 20 0.4 0.003 true 1.5 true 2 20 2.1 30 1.4 true  6.7 true 6.2 âœ…
// æµ‹è¯•å¹´åŒ–:
//    2022-08-11 2023-01-01 16.99%
//    2023-01-01 2024-01-01 57.46%
//    2024-01-01 2025-01-01 512.89%
//    2025-01-01 2025-09-01 419.95%
// æµ‹è¯•æ€»æ”¶ç›Š:
//    2022-08-11 2025-09-01 5330.51%
// ================================

//@version=6
strategy(title = "BoilDetector",
     shorttitle = "Boil",
     overlay = true,
     initial_capital = 10000,
     max_bars_back = 5000,
     commission_type = strategy.commission.percent, 
     commission_value = 0.01,
     calc_on_every_tick = false, 
     process_orders_on_close = true,
     pyramiding = 0,
     default_qty_type = strategy.percent_of_equity, 
     default_qty_value = 90)

// ================================
// å‚æ•°åŒº
// ================================
grpCore   = "æ ¸å¿ƒé€»è¾‘"
N         = input.int(12, "ç›˜æ•´æ£€æµ‹çª—å£ N", minval = 5, group = grpCore, tooltip = "ç”¨äºATRã€å‡é‡ã€å®ä½“å‡å€¼ç­‰ç»Ÿè®¡")
rangeCapK = input.int(8, "çª„åŒºé—´è¿ç»­Kçº¿é˜ˆå€¼(è¡Œä¸ºå‘¨æœŸ)", minval = 3, group = grpCore, tooltip = "ç”¨äºè¾…åŠ©è¯†åˆ«è¿ç»­çª„æ³¢åŠ¨æ¨ªç›˜çš„æœ€å°Kçº¿æ•°")
lowVolPct = input.float(0.25, "ä½æ³¢åŠ¨ç™¾åˆ†ä½è¿‘ä¼¼(0~1)", minval = 0.05, maxval = 1.0, step=0.01, group = grpCore, tooltip = "ä»¥åŒºé—´æ³•è¿‘ä¼¼â€œè¿‘æœŸæœ€ä½20%â€")
boxTightK = input.float(1.4, "ç®±ä½“ç´§è‡´åº¦é˜ˆå€¼(ç›¸å¯¹å¹³å‡æ³¢å¹…)", minval = 0.1, step=0.1, maxval = 3, group = grpCore, tooltip = "ç®±ä½“é«˜åº¦ < å¹³å‡çœŸæ³¢å¹…*è¯¥ç³»æ•° => è®°ä½œâ€œçª„â€")
volMeanLen= input.int(20, "å‡é‡å‘¨æœŸ", minval = 10, group = grpCore)
volShrink = input.float(0.4, "ç¼©é‡é˜ˆå€¼(ç›¸å¯¹å‡é‡)", minval = 0.3, step=0.1, maxval = 10, group = grpCore)

grpBreak  = "çªç ´åˆ¤å®š"
brBufPct  = input.float(0.003, "çªç ´ç¼“å†²(Â±%)", step = 0.001, minval = 0.0, group = grpBreak, tooltip = "å¦‚ 0.003=0.3%")
useBody   = input.bool(true, "éœ€è¦å¤§å®ä½“Kçº¿ç¡®è®¤", group = grpBreak)
bodyMult  = input.float(1.5, "å¤§å®ä½“å€æ•°(ç›¸å¯¹è¿‘Nå‡å®ä½“)", minval = 1.0, step = 0.1, group = grpBreak)
need2Bar  = input.bool(true, "éœ€è¦è¿ç»­ä¸¤æ ¹åŒå‘ç¡®è®¤", group = grpBreak)

grpPulse  = "è„‰å†²è¿‡æ»¤"
volMult   = input.float(2.0, "æ”¾é‡å€æ•°(å½“å‰/å‡é‡)", minval = 1.0, step = 0.1, group = grpPulse)
zLen      = input.int(20, "Z-Scoreé•¿åº¦", minval = 10, group = grpPulse)
zThr      = input.float(2.1, "Z-Scoreé˜ˆå€¼", minval = 1.0, step = 0.1, group = grpPulse)

grpRisk   = "é£æ§ä¸å‡ºåœº"
slMode    = input.string("BOX_OR_ATR", "åˆå§‹æ­¢æŸæ¨¡å¼", options = ["BOX_ONLY", "ATR_ONLY", "BOX_OR_ATR"], group = grpRisk)
atrLen    = input.int(30, "ATRé•¿åº¦", minval = 5, group = grpRisk)
atrMultSL = input.float(1.4, "ATRæ­¢æŸå€æ•°", minval = 0.5, step = 0.1, group = grpRisk)
useTSLL   = input.bool(true, "å¯ç”¨TSLL(ATRè·Ÿè¸ª)", group = grpRisk, tooltip = "ç”¨ATRåšåŠ¨æ€è·Ÿè¸ªæ­¢æŸ")
tsllMult  = input.float(6.7, "TSLL ATR å€æ•°", minval = 0.5, step = 0.1, group = grpRisk)
useTP     = input.bool(true, "å¯ç”¨RRæ­¢ç›ˆ", group = grpRisk)
rr        = input.float(6.2, "RR æ¯”ä¾‹(æ­¢ç›ˆ:æ­¢æŸ)", minval = 1.0, step = 0.1, group = grpRisk)

grpViz    = "å¯è§†åŒ–"
showBox   = input.bool(true, "ç»˜åˆ¶ç›˜æ•´ç®±ä½“", group = grpViz)

// ================================
// åŸºç¡€é‡åŒ–
// ================================
atr = ta.atr(atrLen)
tr  = ta.tr(true)
avgTR = ta.sma(tr, N)

// è¿‘Nå®ä½“å‡å€¼
body = math.abs(close - open)
avgBody = ta.sma(body, N)

// æˆäº¤é‡ç»Ÿè®¡
volEma = ta.ema(volume, volMeanLen)
volSma = ta.sma(volume, volMeanLen)
volBase = na(volEma) ? volSma : volEma
volStdev = ta.stdev(volume, zLen)

zLen_ema_volume = ta.ema(volume, zLen)
z = volStdev == 0.0 ? 0.0 : (volume - zLen_ema_volume) / volStdev

// ç›˜æ•´â€œä¸‰åˆ†åˆ¶è¯„åˆ†â€
// 1) ä½æ³¢åŠ¨ï¼šATR ä½äºè¿‘NåŒºé—´åº•éƒ¨çš„ lowVolPct è¿‘ä¼¼
atrMin = ta.lowest(atr, N)
atrMax = ta.highest(atr, N)
atrBand = atrMax - atrMin
atrLowBand = atrMin + atrBand * lowVolPct
isLowVol = atr <= atrLowBand

// 2) çª„åŒºé—´ï¼šæœ€è¿‘ N æ ¹çš„ç®±ä½“é«˜åº¦ç›¸å¯¹å¹³å‡çœŸæ³¢å¹…è¶³å¤Ÿå°
boxHighN = ta.highest(high, N)
boxLowN  = ta.lowest(low, N)
boxHeight= boxHighN - boxLowN
isTight  = boxHeight <= avgTR * boxTightK

// 3) ç¼©é‡ï¼šå½“å‰é‡ < å‡é‡ * volShrink
isShrink = volume <= volBase * volShrink

score = (isLowVol ? 1 : 0) + (isTight ? 1 : 0) + (isShrink ? 1 : 0)
isConsolidation = score >= 2

// è¡Œä¸ºå‘¨æœŸè¾…åŠ©ï¼šè¿ç»­ rangeCapK æ ¹â€œä½æ³¢åŠ¨çª„æ³¢åŠ¨â€
narrowBar = tr <= avgTR * boxTightK
narrowStreak = ta.barssince(not narrowBar)
consAssist = narrowStreak >= rangeCapK - 1

isDeadWater = isConsolidation or consAssist

// åŠ¨æ€ç›˜æ•´åŒºï¼šå½“å¤„äºç›˜æ•´æ—¶åˆ·æ–°ï¼Œå¦åˆ™ä¿æŒæœ€è¿‘ä¸€æ¬¡ç›˜æ•´åŒº
var float boxHigh = na
var float boxLow  = na
var int   boxSetBar = na

if isDeadWater
    boxHigh := boxHighN
    boxLow  := boxLowN
    boxSetBar := bar_index

// ================================
// çªç ´è¯†åˆ«
// ================================
bufUp = not na(boxHigh) ? boxHigh * brBufPct : high * brBufPct
bufDn = not na(boxLow)  ? boxLow  * brBufPct : low  * brBufPct

breakUp = not na(boxHigh) and close > boxHigh + bufUp
breakDn = not na(boxLow)  and close < boxLow  - bufDn

// å¤§å®ä½“ç¡®è®¤ï¼ˆå¯é€‰ï¼‰
bigBody = body > avgBody * bodyMult
okBodyUp = not useBody or (bigBody and close > open)
okBodyDn = not useBody or (bigBody and close < open)

// ä¸¤æ ¹åŒå‘ç¡®è®¤ï¼ˆå¯é€‰ï¼‰
dirUp2 = breakUp and (not need2Bar or (close > close[1] and high > high[1]))
dirDn2 = breakDn and (not need2Bar or (close < close[1] and low  < low[1]))

// ================================
// è„‰å†²ç¡®è®¤ï¼ˆæ”¾é‡ + Z-Scoreï¼‰
// ================================
pulse = (volume >= volBase * volMult) and (z >= zThr)

// ç»ˆæè§¦å‘ï¼šçªç ´ + è„‰å†² + å®ä½“/ä¸¤æ ¹è¿‡æ»¤
longSignal  = dirUp2 and okBodyUp and pulse
shortSignal = dirDn2 and okBodyDn and pulse

// ================================
// é£æ§ï¼šåˆå§‹æ­¢æŸä¸TSLL
// ================================
calcBoxSL_long  = not na(boxLow)  ? boxLow  : na
calcBoxSL_short = not na(boxHigh) ? boxHigh : na

calcAtrSL_long  = close - atrMultSL * atr
calcAtrSL_short = close + atrMultSL * atr

getInitSL_long() =>
    switch slMode
        "BOX_ONLY"     => calcBoxSL_long
        "ATR_ONLY"     => calcAtrSL_long
        => math.max(calcBoxSL_long, calcAtrSL_long)  // å–æ›´ä¿å®ˆçš„ä¸€ä¾§ï¼ˆç¦»ä»·æ ¼æ›´è¿œï¼‰

getInitSL_short() =>
    switch slMode
        "BOX_ONLY"     => calcBoxSL_short
        "ATR_ONLY"     => calcAtrSL_short
        => math.min(calcBoxSL_short, calcAtrSL_short)

// è¿›åœºä¸è®°å½•é£é™©è·ç¦»
var float longEntrySL = na
var float shortEntrySL = na

// æ¸…ç†ï¼šè‹¥æ— æŒä»“ï¼Œæ¸…ç©ºå†å²SLï¼ˆé˜²è„å€¼å¹²æ‰°ï¼‰
if strategy.position_size == 0
    longEntrySL  := na
    shortEntrySL := na

// è¿›åœº
if (strategy.position_size == 0) and longSignal
    longEntrySL := getInitSL_long()
    if not na(longEntrySL) and longEntrySL < close
        strategy.entry("LONG", strategy.long)
if (strategy.position_size == 0) and shortSignal
    shortEntrySL := getInitSL_short()
    if not na(shortEntrySL) and shortEntrySL > close
        strategy.entry("SHORT", strategy.short)

// è®¡ç®— TSLL è½¨è¿¹ï¼ˆæ‰‹åŠ¨ï¼‰ï¼Œä¾¿äºå¯è§†åŒ–ä¸æ¡ä»¶å‡ºåœº
var float tsllLong = na
var float tsllShort = na

inLong  = strategy.position_size > 0
inShort = strategy.position_size < 0
avgPx   = strategy.position_avg_price

barsSinceEntry = ta.barssince(strategy.position_size == 0)
lenLookback = na(barsSinceEntry) ? atrLen : barsSinceEntry + 1

hh = ta.highest(high, lenLookback)
ll = ta.lowest(low, lenLookback)

if inLong
    tsllLong := hh - tsllMult * atr
if inShort
    tsllShort := ll + tsllMult * atr
if strategy.position_size == 0
    tsllLong := na
    tsllShort := na

// è®¡ç®—æ­¢ç›ˆä»·æ ¼ï¼ˆåŸºäºRRï¼‰
longRisk  = inLong  ? (avgPx - (na(longEntrySL) ? avgPx - atrMultSL * atr : longEntrySL))  : na
shortRisk = inShort ? ((na(shortEntrySL) ? avgPx + atrMultSL * atr : shortEntrySL) - avgPx) : na
tpLong  = useTP and inLong  and not na(longRisk)  ? avgPx + rr * longRisk  : na
tpShort = useTP and inShort and not na(shortRisk) ? avgPx - rr * shortRisk : na

crossunder_tsllLong = ta.crossunder(close, tsllLong)
crossunder_tsllShort = ta.crossover(close, tsllShort)

// å‡ºåœºé€»è¾‘ï¼šä¼˜å…ˆ TSLLï¼Œå…¶æ¬¡åˆå§‹SLï¼Œå¦å¤–è€ƒè™‘RRæ­¢ç›ˆ
exitLong_TSLL = useTSLL and inLong  and not na(tsllLong)  and crossunder_tsllLong
exitShort_TSLL= useTSLL and inShort and not na(tsllShort) and crossunder_tsllShort

exitLong_BoxSL_longEntrySL = ta.crossunder(close, longEntrySL)
exitShort_BoxSL_shortEntrySL = ta.crossover(close, shortEntrySL)

exitLong_BoxSL = inLong  and not na(longEntrySL)  and exitLong_BoxSL_longEntrySL
exitShort_BoxSL= inShort and not na(shortEntrySL) and exitShort_BoxSL_shortEntrySL

exitLong_TP_tpLong = ta.crossover(close, tpLong)
exitShort_TP_tpShort = ta.crossunder(close, tpShort)

exitLong_TP  = useTP and inLong  and not na(tpLong)  and exitLong_TP_tpLong
exitShort_TP = useTP and inShort and not na(tpShort) and exitShort_TP_tpShort

// æ‰§è¡Œå‡ºåœºï¼ˆç”¨å¸‚ä»·æ¨¡æ‹Ÿï¼Œä¼˜å…ˆæ»¡è¶³æœ€å…ˆè§¦å‘çš„æ¡ä»¶ï¼‰
if exitLong_TSLL or exitLong_BoxSL or exitLong_TP
    strategy.close("LONG", comment = exitLong_TSLL ? "TSLL" : exitLong_BoxSL ? "BOX/ATR SL" : "TP")
if exitShort_TSLL or exitShort_BoxSL or exitShort_TP
    strategy.close("SHORT", comment = exitShort_TSLL ? "TSLL" : exitShort_BoxSL ? "BOX/ATR SL" : "TP")

// äº‹ä»¶é©±åŠ¨ï¼šè‹¥äº§ç”Ÿçªç ´ä¿¡å·ï¼ˆæ— è®ºæ˜¯å¦è¿›åœºæˆåŠŸï¼‰ï¼Œé‡ç½®â€œæ—§ç›˜æ•´â€ï¼Œç­‰å¾…ä¸‹ä¸€ä¸ªæ­»æ°´
if longSignal or shortSignal
    // é‡ç½®çš„ç­–ç•¥ï¼šè®©æ–°ä¸€è½®ç›˜æ•´éœ€é‡æ–°ç§¯ç´¯åˆ†æ•°
    boxHigh := na
    boxLow  := na
    boxSetBar := na

// ================================
// å¯è§†åŒ–
// ================================
plot(showBox and not na(boxHigh) ? boxHigh : na, "Consolidation High", style=plot.style_linebr, linewidth=2)
plot(showBox and not na(boxLow)  ? boxLow  : na, "Consolidation Low",  style=plot.style_linebr, linewidth=2)
